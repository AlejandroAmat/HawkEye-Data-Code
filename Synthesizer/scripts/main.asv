function [radar_heatmap, visible_cart_v] = main
    % Copyright (c) 2018-2020 Junfeng Guan, Sohrab Madani, Suraj Jog, Saurabh Gupta, 
    % Haitham Hassanieh, University of Illinois at Urbana-Champaign
    % 
    % Permission is hereby granted, free of charge, to any person obtaining a copy
    % of this software and associated documentation files (the "Software"), to deal
    % in the Software without restriction, including without limitation the rights
    % to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    % copies of the Software, and to permit persons to whom the Software is
    % furnished to do so, subject to the following conditions:
    % 
    % The above copyright notice and this permission notice shall be included in
    % all copies or substantial portions of the Software.
    % 
    % THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    % IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    % FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    % AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    % LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    % OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    % THE SOFTWARE.

    close all; clear; clc;
    addpath('functions');

    variable_library;
    variable_library_radar;
    %lee el archivo .pointcloud (el mío era .stl):




    %Import an STL mesh, returning a PATCH-compatible face-vertex structure
    % fv = stlread('../../w.stl');
    % nTx = 1;    
    % points = fv.Points;
    % [points_size, cdd] = size(points);
    
    

     %operaciones con el PointCloud--> Yo he interpolado para tener mas
     %puntos y he dividido entre 6 para tamaño humano


    %Linear interpolation of the points
    % pointsX = interp1(1:points_size, points(:,1),linspace(1,points_size,points_size*10));
    % pointsY = interp1(1:points_size, points(:,2),linspace(1,points_size,points_size*10));
    % pointsZ = interp1(1:points_size, points(:,3),linspace(1,points_size,points_size*10));
    % pointsTotal = [pointsX' pointsY' pointsZ']/6;
    % ptCloudO = pointCloud(pointsTotal);

    
    % pointsTotal = ptCloud.Location;
    % newPoint = [2, 2, 4];
    % newPoint2 = [-2,-2,4]
    % 
    % pointsTotal = [pointsTotal; newPoint];
    % pointsTotal = [pointsTotal; newPoint2];
    % ptCloud = pointCloud(pointsTotal);

    %Aquí es para comprobar el pointcloud. LA función es propia. Puedes
    %usar la de matlab normal, ya que no te interesa lo del range a ti.

    showPCloud(ptCloud.Location, range)
    title('Original Pointcloud')
       
        %Esto estaba en el codigo original. Puedes borrarlo cambiando las
        %variables de luego por las tuyas. Lo deje por comodidad.
        
        %store point cloud in pc (point cloud) structure
        car_v = car_v_struct;
        car_v.CAD_idx = CAD_idx;
        car_v.N_pt = length(ptCloud.Location);
        car_v.cart_v = ptCloud.Location;
        car_v.lim = [min(ptCloud.Location);max(ptCloud.Location)]; % find the limits in all three dimensions 
        [bbox_x, bbox_y, bbox_z] = meshgrid(car_v.lim(:,1),car_v.lim(:,2),car_v.lim(:,3)); % 8 vertices of the bounding box of the point cloud
        car_v.bbox = [bbox_x(:), bbox_y(:), bbox_z(:)]; 
        %clear cart_v bbox N_pt car_idx;
        car1_v_origin = car_v;
        car_scene_v = car1_v_origin;

            %% Modle radar point reflectors in the scene
            %% Modle radar point reflectors in the scene
            [visible_cart_v ] = remove_occlusion(car_scene_v); % remove occluded body of the car
            
            reflector_cart_v = model_point_reflector(visible_cart_v,car_scene_v.bbox); % model point reflectors that reflect back to the radar receiver
            

            if isempty(reflector_cart_v)
                return;
            end
            
            % pcshow(visible_cart_v);
            % title('occlusion')

            % showPCloud(reflector_cart_v, range)
            % title('Reflector Model')
            
             
            %número de antenas Tx (o array de antenas. Depende de como lo
            %hagas)

            for Tx=1:nTx
                %% Simualte received radar signal in the receiver antenna array
                %Tx_Pos es el vector de posiciones de Tx. Por lo q dijo
                %Filip solo tendrás 1

                signal_array = simulate_radar_signal(reflector_cart_v_d, TX_pos(Tx,:));

                %% Radar signal processing, generating 3D radar heatmaps
                radar_heatmap = radar_dsp(signal_array);

                %% Guardar datos
                
                % Visulize the radar heatmap top view
                radar_heatmap_top = squeeze(max(radar_heatmap,[],3));
                figure
                imagesc(radar_heatmap_top);    
                set(gca,'XDir','reverse')
                set(gca,'YDir','normal')
                colormap jet; caxis([0 1e11]);
                xlabel('Range'); ylabel('Azimuth');
                set(gca,'FontSize',30) % Creates an axes and sets its FontSize to 18
                % 
                % saveas(gcf,['../results/',new_folder,'/', num2str(CAD_idx),'-',num2str(Tx), 'Top.jpg'])
                % 
                % % Visulize the radar heatmap front view
                % radar_heatmap_front = squeeze(max(radar_heatmap,[],1));
                % figure;
                % imagesc(radar_heatmap_front.');    
                % set(gca,'XDir','reverse')
                % colormap jet; caxis([0 1e11]);
                % xlabel('Azimuth'); ylabel('Elevation');
                % set(gca,'FontSize',30) % Creates an axes and sets its FontSize to 18
                % saveas(gcf,['../results/',new_folder,'/' num2str(CAD_idx),'-',num2str(Tx), 'Front.jpg'])
                % 
  
                % save(['../results/',new_folder,'/','HeatMap',num2str(CAD_idx), '.mat'], 'radar_heatmap');
            end
            
            
        
    
    
end
